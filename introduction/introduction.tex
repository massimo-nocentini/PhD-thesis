


\textit{Combinatorics. Logic. Programming.} This dissertation is an attempt to
explore how each entity relates to the others. Seen as a set of rules that
characterize our methodology, we apply and use them to study the topic of
\textit{infinite~sequences}.  Our approach is two-fold, it allows us, first, to
prove theoretical results about them; second, to built an orbit around them
composed of side-track techniques that helps our main goal, such as programming
techniques and logical reasoning.

In particular, the research field of interest concerns (i)~the manipulation of
a set of matrices that can be algebraically defined, which deserve interest
both as standalone objects and as tools to study other combinatorial
structures; (ii)~the \textit{practice of programming} that exposes our way of
thinking to its paradigms, functional and relational in particular, and
(iii)~the rigor and power of \textit{mechanized logic}.

In normal conditions, it is hard to tackle a problem in our context with both
entities present at the same time; however, we sacrifice a direct approach to
solve the given questions to get the most out of the process that uses the
three tenets together. In this philosophy the constant delay, needed to sharpen
our knowledge in each individual field, is balanced by the discovery of
relations among apparently unrelated subjects that when mixed together yield
nicer, more elegant and possibly unexpected solutions.

For this reason we spread our focus over many topics of mathematics and
computer science instead of composing a mono-theme discussion; pairwise,
we deepen into
\begin{description}

    \item[Combinatorics and Programming] the implementation of enumeration
    techniques for classes of combinatorial objects from both the algebraic
    and applicative points of view;

    \item[Programming and Logic] the study of a family of languages designed
    for relational programming, using a general purpose inference engine to
    perform deductions over domain specific objects;

    \item[Logic and Combinatorics] the formalization of proofs to which
    corresponds certified enumerations of classes of objects, using an extended
    theorem prover based on Higher Order Logic.

\end{description}

Even though abstract reasoning took place most of the time, we make
some room for practical stuff; in particular, we would like to provide a suite
of tools that helps interacting with the Online Encyclopedia of Integer
Sequences, to automate fetching, printing and graphing the networks they
compose. Moreover, some practice with bitmasking and backtracking techniques is
done to show some interesting tiling and enumeration problems.

Another force that drove our work is a pedagogical approach to problem solving,
hence we preferred to refine a first, naive solution over and over to cut away
unnecessary details and complexities; moreover, we don't seek for efficiency in
all cases in favor of simple and beauty definitions. This methodology allows us
to use many programming languages and environments to support theoretical
derivations and this dissertation collects this heterogeneous pool of techniques.


\section*{Structure}

This dissertation has 5 main chapters that rely on the first one, which
introduces basic definitions needed by the following ones; so, except for the
first, the others can be read in any order,
\begin{itemize}
\item Chapter \ref{ch:backgrounds} quickly recalls the theory characterizing
the Riordan group and provides a set of constructors to define those matrices
programmatically, after the introduction of the symbolic module Sympy
implemented on top of the Python programming language. Moreover, it shows our
programming style which is based on consecutive manipulation of symbolic
equations, as mush as possible close to paper and pencil derivations.
\item Chapter \ref{ch:Riordan-matrices-function} presents a theoretical and
practical framework that lifts a scalar function to a matrix function, toward
application to Riordan matrices. To the best of our knowledge, this is the
first implementation that allows the user to perform its computations fully
symbolically, postponing to the end the substitution of ground values to fill
matrices with numbers. Moreover, the Jordan Canonical Form of Riordan matrices
is also studied.
\item Chapter \ref{ch:algebraic-gfs-languages-avoiding-Riordan-patterns}
studies the enumeration of languages of binary words avoiding a given pattern,
provided that some contraints over the structure of each word are taken into
account.  In particular, when the pattern to avoid is a Riordan pattern then
the problem can be solved using Riordan arrays, deriving new series
developments about enumerations with respect to the number of $1$-bits and to
the length. Finally, some combinatorial interpretations are shown, at least for
simpler families of languages.
\item Chapter \ref{ch:OEIS:tools} implements a suite of tools that interact with
the Online Encyclopedia of Integer Sequences; in particular, a (i)~crawler fetches
sequences and their cross references recursively, using asynchronous primitive
to optimize network delays, a (ii)~(pretty) printer for the fetched sequences that
allows the user to filter the sections to be rendered both in the terminal and in
web interfaces and, finally, a (iii)~grapher that draw graphs where vertices
are sequences and edges are references among them.
\item Chapter \ref{ch:queens-tilings-polyominoes} is an exercise in
backtracking techniques to solve tiling and placement problems; for the sake of
efficiency, bit masking manipulation and encodings are used. Moreover, it
provides an implementation of a classic enumeration methodology that allows us
to clearly show generations of combinatorial objects starting from concise and
recursive symbolic definitions; finally, counting all of them is a check of
the correctness of our implementation.
\item Chapter \ref{ch:scilp} proposes an extension to the tactic mechanism
actually present in the HOL Light theorem prover inspired by the relational
paradigm. This prototype makes explicit use of meta-variables to support
substitutions and allows backtracking facilities during the interactive proof
process; nonetheless, the proposed generalization offers compositionality just
as the current system does. So this extension is stressed against an evaluator
for a subset of the Lisp language to find a \textit{quine} program.
\end{itemize}

Moreover, a final paragraph concludes with a quick summary of our main results
and the bibliography ends this dissertation.

\section*{Typographical and typesetting conventions}

This dissertation was typeset using the \LaTeX\,'s style \verb|tufte-book|,
which splits each page into two columns: the left-most is greater in width and
holds the main body, while the right-most is lesser and holds captions,
contextual data and code comments; in particular, code chunks are printed in
\verb|verbatim| and highlighted wherever possible, while outputs that denote
mathematical objects are printed in math style, as usual -- when their size
overflows over the right column we prefer to allow it to take the entire
page width for the sake of clarity.




